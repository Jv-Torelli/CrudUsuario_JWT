# üìö Entendendo Lambda e Map - Guia Completo

## üéØ O que s√£o Express√µes Lambda?

**Lambda** √© uma forma CURTA de escrever fun√ß√µes em Java (a partir do Java 8).

### Forma Tradicional vs Lambda

```java
// ‚ùå FORMA TRADICIONAL (antes do Java 8)
List<String> nomes = Arrays.asList("Jo√£o", "Maria", "Pedro");

for (String nome : nomes) {
    System.out.println(nome);
}

// ‚úÖ COM LAMBDA (Java 8+)
nomes.forEach(nome -> System.out.println(nome));
```

### Anatomia de uma Lambda

```java
(par√¢metros) -> { corpo da fun√ß√£o }

// Exemplos:
(x) -> x * 2                    // Multiplica por 2
(a, b) -> a + b                 // Soma dois n√∫meros
nome -> nome.toUpperCase()      // Transforma em mai√∫scula
() -> System.out.println("Oi")  // Sem par√¢metros
```

---

## üó∫Ô∏è O que √© Map?

**Map** √© uma opera√ß√£o de TRANSFORMA√á√ÉO em cole√ß√µes (listas, arrays, etc).

### Conceito Visual

```
Lista Original:  [1, 2, 3, 4, 5]
                      map(x -> x * 2)
Lista Resultante: [2, 4, 6, 8, 10]
```

**Map pega cada elemento e transforma em algo novo.**

---

## üîÑ Stream, Map e Collect

### Passo a Passo

```java
List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5);

List<Integer> dobrados = numeros.stream()      // 1. Criar stream
                                .map(x -> x * 2)  // 2. Transformar
                                .collect(Collectors.toList()); // 3. Coletar

// Resultado: [2, 4, 6, 8, 10]
```

### Explica√ß√£o Detalhada

#### 1Ô∏è‚É£ `.stream()`
Transforma a lista em um "fluxo de dados" que permite opera√ß√µes encadeadas.

```java
[1, 2, 3, 4, 5]  ‚Üí  Stream<1, 2, 3, 4, 5>
```

#### 2Ô∏è‚É£ `.map(fun√ß√£o)`
Aplica uma fun√ß√£o em CADA elemento do stream.

```java
Stream<1, 2, 3, 4, 5>
     map(x -> x * 2)
Stream<2, 4, 6, 8, 10>
```

#### 3Ô∏è‚É£ `.collect()`
Coleta os elementos transformados de volta em uma lista.

```java
Stream<2, 4, 6, 8, 10>  ‚Üí  [2, 4, 6, 8, 10]
```

---

## üìù Exemplos Pr√°ticos do Projeto

### Exemplo 1: Converter Entity para DTO

```java
// NO SERVICE: UsuarioService.java

public List<UsuarioResponseDTO> listarTodos() {
    // 1. Buscar todas as entidades do banco
    List<UsuarioEntity> entities = repository.findAll();
    // Resultado: [Entity1, Entity2, Entity3]

    // 2. Criar stream
    Stream<UsuarioEntity> stream = entities.stream();
    // Resultado: Stream<Entity1, Entity2, Entity3>

    // 3. Transformar cada Entity em DTO
    Stream<UsuarioResponseDTO> dtoStream = stream.map(mapper::toResponseDTO);
    // Resultado: Stream<DTO1, DTO2, DTO3>

    // 4. Coletar em uma lista
    List<UsuarioResponseDTO> dtos = dtoStream.collect(Collectors.toList());
    // Resultado: [DTO1, DTO2, DTO3]

    return dtos;
}
```

### Vers√£o Compacta (como est√° no c√≥digo)

```java
public List<UsuarioResponseDTO> listarTodos() {
    return repository.findAll()
            .stream()
            .map(mapper::toResponseDTO)
            .collect(Collectors.toList());
}
```

---

## üîó Method Reference (::)

`mapper::toResponseDTO` √© uma **refer√™ncia de m√©todo**.

### Equival√™ncia

```java
// Com LAMBDA COMPLETA
.map(entity -> mapper.toResponseDTO(entity))

// Com METHOD REFERENCE (mais curto)
.map(mapper::toResponseDTO)
```

Ambos fazem a MESMA COISA!

### Quando Usar Method Reference?

‚úÖ Quando a lambda apenas chama um m√©todo:
```java
.map(user -> user.getName())    // Pode virar: .map(User::getName)
.forEach(x -> System.out.println(x))  // Pode virar: .forEach(System.out::println)
```

‚ùå Quando a lambda faz mais coisas:
```java
.map(x -> x * 2 + 1)  // N√£o pode usar ::
.filter(x -> x > 10 && x < 20)  // N√£o pode usar ::
```

---

## üí° Outros Exemplos de Map

### Exemplo 1: Extrair Nomes

```java
List<UsuarioEntity> usuarios = repository.findAll();

// Pegar apenas os nomes
List<String> nomes = usuarios.stream()
                             .map(usuario -> usuario.getNomeCompleto())
                             // ou: .map(UsuarioEntity::getNomeCompleto)
                             .collect(Collectors.toList());

// Se temos: [Jo√£o Silva, Maria Santos, Pedro Costa]
// Resultado: ["Jo√£o Silva", "Maria Santos", "Pedro Costa"]
```

### Exemplo 2: Calcular Idades

```java
List<UsuarioEntity> usuarios = repository.findAll();

// Calcular idade de cada usu√°rio
List<Integer> idades = usuarios.stream()
    .map(usuario -> {
        LocalDate nascimento = usuario.getDataNascimento();
        LocalDate hoje = LocalDate.now();
        return Period.between(nascimento, hoje).getYears();
    })
    .collect(Collectors.toList());

// Resultado: [33, 25, 40, ...]
```

### Exemplo 3: Formatar CPFs

```java
List<UsuarioEntity> usuarios = repository.findAll();

// Formatar CPF: 12345678901 -> 123.456.789-01
List<String> cpfsFormatados = usuarios.stream()
    .map(usuario -> {
        String cpf = usuario.getCpf();
        return cpf.substring(0, 3) + "." +
               cpf.substring(3, 6) + "." +
               cpf.substring(6, 9) + "-" +
               cpf.substring(9, 11);
    })
    .collect(Collectors.toList());
```

---

## üéì Compara√ß√£o: For vs Stream + Map

### Usando FOR tradicional

```java
List<UsuarioEntity> entities = repository.findAll();
List<UsuarioResponseDTO> dtos = new ArrayList<>();

for (UsuarioEntity entity : entities) {
    UsuarioResponseDTO dto = mapper.toResponseDTO(entity);
    dtos.add(dto);
}

return dtos;
```

### Usando STREAM + MAP

```java
return repository.findAll()
        .stream()
        .map(mapper::toResponseDTO)
        .collect(Collectors.toList());
```

### Vantagens do Stream + Map

‚úÖ **C√≥digo mais curto** - 4 linhas vs 1 linha
‚úÖ **Mais leg√≠vel** - Expressa a inten√ß√£o claramente
‚úÖ **Funcional** - Sem vari√°veis mut√°veis
‚úÖ **Encade√°vel** - Pode adicionar .filter(), .sorted(), etc
‚úÖ **Paraleliz√°vel** - Pode usar .parallelStream() para processar em paralelo

---

## üî• Opera√ß√µes Comuns com Stream

### Filter (Filtrar)

```java
// Buscar apenas usu√°rios ativos
List<UsuarioEntity> ativos = repository.findAll()
    .stream()
    .filter(usuario -> usuario.getAtivo() == true)
    .collect(Collectors.toList());
```

### Sorted (Ordenar)

```java
// Ordenar por nome
List<UsuarioEntity> ordenados = repository.findAll()
    .stream()
    .sorted((u1, u2) -> u1.getNomeCompleto().compareTo(u2.getNomeCompleto()))
    .collect(Collectors.toList());
```

### Limit (Limitar)

```java
// Pegar apenas os 10 primeiros
List<UsuarioEntity> primeiros = repository.findAll()
    .stream()
    .limit(10)
    .collect(Collectors.toList());
```

### Count (Contar)

```java
// Contar usu√°rios ativos
long quantidadeAtivos = repository.findAll()
    .stream()
    .filter(usuario -> usuario.getAtivo())
    .count();
```

### Encadeamento

```java
// Buscar emails dos usu√°rios ativos de SP, ordenados por nome
List<String> emails = repository.findAll()
    .stream()
    .filter(u -> u.getAtivo())              // Apenas ativos
    .filter(u -> u.getEstado().equals("SP")) // Apenas de SP
    .sorted((u1, u2) -> u1.getNomeCompleto()
                          .compareTo(u2.getNomeCompleto())) // Ordenar
    .map(UsuarioEntity::getEmail)           // Pegar email
    .collect(Collectors.toList());          // Coletar
```

---

## üéØ Resumo Final

### Lambda
- Fun√ß√£o an√¥nima curta
- Sintaxe: `(par√¢metros) -> express√£o`
- √ötil para c√≥digo mais limpo

### Map
- Transforma cada elemento de uma cole√ß√£o
- Retorna uma nova cole√ß√£o transformada
- N√£o modifica a cole√ß√£o original

### Stream
- Fluxo de dados para processar cole√ß√µes
- Permite encadear opera√ß√µes
- Mais elegante que loops tradicionais

### Method Reference (::)
- Forma ainda mais curta de lambda
- Usado quando lambda s√≥ chama um m√©todo
- `objeto::m√©todo` ou `Classe::m√©todo`

---

## üìñ Exemplo Completo Comentado

```java
// Cen√°rio: Transformar lista de usu√°rios do banco em DTOs para resposta

public List<UsuarioResponseDTO> listarTodos() {

    // PASSO 1: Buscar do banco
    // Retorna: List<UsuarioEntity>
    List<UsuarioEntity> entities = repository.findAll();

    // PASSO 2: Criar stream (fluxo de dados)
    // Transforma em: Stream<UsuarioEntity>
    Stream<UsuarioEntity> stream = entities.stream();

    // PASSO 3: Transformar cada Entity em DTO
    // Para CADA entity:
    //   - Chama mapper.toResponseDTO(entity)
    //   - Retorna um DTO
    // Resultado: Stream<UsuarioResponseDTO>
    Stream<UsuarioResponseDTO> streamDto = stream.map(
        entity -> mapper.toResponseDTO(entity)
        // OU de forma mais curta:
        // mapper::toResponseDTO
    );

    // PASSO 4: Coletar tudo em uma lista
    // Transforma de volta em: List<UsuarioResponseDTO>
    List<UsuarioResponseDTO> dtos = streamDto.collect(Collectors.toList());

    // PASSO 5: Retornar
    return dtos;

    // =====================================================
    // VERS√ÉO COMPACTA (tudo em uma linha):
    // =====================================================
    // return repository.findAll()
    //         .stream()
    //         .map(mapper::toResponseDTO)
    //         .collect(Collectors.toList());
}
```

---

## üöÄ Dica de Aprendizado

1. **Comece com FOR** - Se voc√™ √© iniciante, use for tradicional primeiro
2. **Entenda o conceito** - Compreenda o que cada opera√ß√£o faz
3. **Pratique convers√£o** - Pegue c√≥digos com for e converta para stream
4. **Use gradualmente** - N√£o precisa usar stream em tudo, use onde faz sentido

**Lembre-se:** O objetivo √© CLAREZA, n√£o mostrar que sabe usar lambdas!